<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>리스코프 치환 원칙 (LSP) &#8211; codehumane</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="SOLID의 리스코프 치환 원칙&lt;sup&gt;Liskov Substitution Principle&lt;/sup&gt; 소개">
    <meta name="author" content="Gunhee Cho">
    <meta name="keywords" content="">
    <link rel="canonical" href="//2016/06/03/%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3-%E1%84%8E%E1%85%B5%E1%84%92%E1%85%AA%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for codehumane" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?201606040950" type="text/css">

    <!-- Fonts -->
    <!-- <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'> -->
    <!-- <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'> -->
    <link href='//fonts.googleapis.com/earlyaccess/nanumgothic.css' rel='stylesheet' type='text/css'>
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="리스코프 치환 원칙 (LSP)">
    <meta property="og:description" content="소프트웨어 개발 이야기">
    <meta property="og:url" content="//2016/06/03/%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3-%E1%84%8E%E1%85%B5%E1%84%92%E1%85%AA%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/">
    <meta property="og:site_name" content="codehumane">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
    <meta name="twitter:title" content="리스코프 치환 원칙 (LSP)" />
    <meta name="twitter:description" content="SOLID의 리스코프 치환 원칙<sup>Liskov Substitution Principle</sup> 소개" />
    <meta name="twitter:url" content="//2016/06/03/%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3-%E1%84%8E%E1%85%B5%E1%84%92%E1%85%AA%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-76183388-1', 'auto');
    ga('send', 'pageview');
  </script>
</head>

<body class="site">

	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="/" class="site-title">codehumane</a>
      <nav class="site-nav">
        
    

    
        <a href="/about/">About</a>
    

    

    

    

    

    


    

    

    

    

    

    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>리스코프 치환 원칙 (LSP)</h1>
  <span class="post-meta">Jun 3, 2016</span><br>
  
  <span class="post-meta small">
  
    2 minute read
  
  </span>
</div>

<article class="post-content">
  <p>SOLID의 세 번째 원칙인 리스코프 치환 원칙<sup>Liskov substitution principle</sup>에 대해 알아보도록 한다.</p>

<h2 id="section">리스코프 치환 원칙이란?</h2>

<blockquote>
  <p>“FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT.”</p>

  <p>– <cite>Robert Martin. <a href="https://drive.google.com/file/d/0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh/view">LSP: The Liskov Substitution Principle</a></cite></p>
</blockquote>

<p>기반 클래스<sup>base class</sup>의 사용자는 파생 클래스<sup>derived class</sup>의 존재를 몰라도 기반 클래스를 사용할 수 있어야 한다. LSP를 위반한다는 것은 기반 클래스를 참조하면서 파생 클래스들에 대해서도 알고 있는 것이다. 이런 코드는 파생 클래스들이 추가될 때 마다 수정될 가능성이 높다. 즉, 수정에 닫혀 있지 못한 OCP 위반이 된다.</p>

<p>이를 설명하는 여러 예제가 있지만 사각형과 정사각형 이야기가 가장 흥미롭다. 아래 그림을 먼저 보도록 하자.</p>

<p><img src="/images/리스코프-치환-원칙-LSP/그림1-ISA.png" alt="two" /></p>

<p>그림 1. 사각형을 상속하는 정사각형</p>

<p>‘정사각형은 사각형이다’라고 할 수 있으므로 <a href="https://en.wikipedia.org/wiki/Is-a">ISA 관계</a>가 성립하는 것 처럼 보인다. 따라서 그림의 상속 관계도 자연스러워 보인다. 하지만 코드와 함께 살펴 보면 이상한 부분들이 보이기 시작한다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Rectangle</span> <span class="o">{</span>

   <span class="nd">@Getter</span>
   <span class="nd">@Setter</span>
   <span class="kd">private</span> <span class="kt">double</span> <span class="n">width</span><span class="o">;</span>

   <span class="nd">@Getter</span>
   <span class="nd">@Setter</span>
   <span class="kd">private</span> <span class="kt">double</span> <span class="n">height</span><span class="o">;</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Square</span> <span class="kd">extends</span> <span class="n">Rectangle</span> <span class="o">{}</span></code></pre></figure>

<p>위 코드는 넓이와 높이 속성을 가진 <i>Rectangle</i>을 <i>Square</i>가 상속하도록 하고 있다. 그런데, <i>Square</i>가 상속하는 속성과 행위가 모두 필요한 걸까? 정사각형은 넓이와 높이가 동일하기 때문에 이는 생각해 볼 일이다. 우선 메모리 사용 측면에서 비효율이다. <i>Square</i> 인스턴스가 생성될 때 마다 매번 2개 필드를 위한 메모리가 사용되기 때문이다. 두 번째로, 코드를 읽는 사람에게 혼란을 야기할 수 있다. “정사각형은 가로 세로가 동일한데 왜 필드가 2개이고 넓이와 높이를 지정하는 메서드가 각각 존재하는 건가?” 자칫 <i>width</i>와 <i>height</i>가 서로 달라지는 오류를 범할 수도 있다. <i>setWidth</i>와 <i>setHeight</i>를 오버라이드 해서 각 메서드 호출 시 마다 <i>width</i>와 <i>height</i>를 항상 동일하게 맞춰준다고 해도 코드의 사용자에게 주는 혼란은 여전하다. 아래 코드 처럼 말이다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">inconsistency</span><span class="p">(</span><span class="n">Rectangle</span> <span class="n">rectangle</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">rectangle</span><span class="o">.</span><span class="na">setHeight</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
   <span class="n">rectangle</span><span class="o">.</span><span class="na">setWidth</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
   <span class="kt">double</span> <span class="n">area</span> <span class="o">=</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()</span> <span class="o">*</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">();</span>
   <span class="k">assert</span> <span class="n">area</span> <span class="o">==</span> <span class="mi">50</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>메모리 비효율과 읽기 혼란을 무시한다고 해도 다른 문제가 남아 있다. <i>Rectangle</i>의 사용자가 <i>Square</i>의 존재를 알아야 한다는 것이다. 이 경우 다음과 같은 코드가 만들어 질 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">ocpViolation</span><span class="p">(</span><span class="n">Rectangle</span> <span class="n">rectangle</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">rectangle</span><span class="o">.</span><span class="na">setHeight</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
   <span class="n">rectangle</span><span class="o">.</span><span class="na">setWidth</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>

   <span class="kt">double</span> <span class="n">area</span> <span class="o">=</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()</span> <span class="o">*</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">();</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">rectangle</span> <span class="k">instanceof</span> <span class="n">Square</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">assert</span> <span class="n">area</span> <span class="o">==</span> <span class="mi">100</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
       <span class="k">assert</span> <span class="n">area</span> <span class="o">==</span> <span class="mi">50</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>기존의 <i>inconsistency</i> 메서드는 <i>Rectangle</i> 객체를 참조하고 있지만 이 객체가 <i>Square</i>(<i>Rectangle</i>의 파생 클래스)의 객체일 때는 기대한 대로 동작하지 않는다. 그래서 <i>ocpViolation</i> 메서드 처럼 별도의 처리가 필요하게 되고, 결국 ‘기반 클래스를 참조하면서 파생 클래스들에 대해서도 알고 있는’ LSP 위반이 된다. 이런 식의 <i>Rectangle</i> 파생 클래스가 추가될 때 마다 ocpViolation도 함께 수정해 주어야 하므로 OCP를 위반하게 된다.</p>

<p>파생 클래스들은 언제든지 기반 클래스로 치환<sup>substitution</sup> 될 수 있어야 하며, 그러기 위해서 모든 파생 클래스들은 기반 클래스의 클라이언트 코드들이 기반 클래스에게 기대하는 것을 반드시 따라야만 한다. 이를 통해 기반 클래스들에 의존하는 코드들이 재사용 가능해지고 기반 클래스들의 변경에 영향 받지 않을 수 있게 된다. 이는 OCP가 추구하는 바 그대로이며, 이런 측면에서 LSP는 OCP를 따르기 위한 수단으로 보여지기도 한다.</p>

<h2 id="section-1">정사각형은 사각형인가?</h2>

<p>정사각형은 사각형이 맞다. 하지만 <i>Square</i>와 <i>Rectangle</i> 클래스는 ISA 관계가 성립하지 않는다. <i>Square</i> 객체의 행위가 <i>Rectangle</i>의 그것과 상이하기 때문이다. <a href="https://docs.oracle.com/javase/tutorial/java/concepts/object.html">상태와 행위를 가지는 것이 객체</a>이고 <a href="https://docs.oracle.com/javase/tutorial/java/concepts/class.html">클래스는 이 객체의 행위를 구현한 템플릿<sup>template</sup></a> 임을 생각할 때 <i>Square</i>는 <i>Rectangle</i>이 아니다.</p>

<h2 id="section-2">참고 문헌</h2>

<p>[1] Robert Martin. <a href="https://drive.google.com/file/d/0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh/view">LSP: The Liskov Substitution Principle.</a> <br />
[2] <a href="https://docs.oracle.com/javase/tutorial/java/concepts/object.html">What is Object?</a> <br />
[3] <a href="https://docs.oracle.com/javase/tutorial/java/concepts/class.html">What is Class?</a> <br /></p>

</article>











      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      <a href="http://github.com/codehumane">Github</a><br>
      <a href="mailto:codehumane@gmail.com">Email</a>
    </small>
  </div>
</footer>

</body>
</html>
