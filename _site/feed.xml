<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>codehumane</title>
    <description>소프트웨어 개발 이야기</description>
    <link>//</link>
    <atom:link href="//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>의존관계 역전 원칙 (DIP)</title>
        <description>&lt;p&gt;이제 SOLID의 마지막 원칙인 의존관계 역전 원칙&lt;sup&gt;Dependency Inversion Principle&lt;/sup&gt;에 대해 알아볼 차례이다. 이전 원칙들을 설명하는 과정에서 재사용성이나 유연성, 강건함 등을 반복적으로 다뤄 보았기에(특히 예제와 함께) 내용이 좀 더 쉽게 와닿지 않을까 기대한다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;의존관계 역전 원칙이란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;“A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS.”&lt;/p&gt;

  &lt;p&gt;“B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTIONS.”&lt;/p&gt;

  &lt;p&gt;– &lt;cite&gt;Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz/view&quot;&gt;ISP: The Dependency Inversion Principle&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안되며, 두 모듈 모두 추상화에 의존해야 한다. 또한 추상화는 세부 내용에 의존해서는 안되고, 세부 내용은 추상화에 의존해야 한다. 이렇게 하면 유연함&lt;sup&gt;flexibility&lt;/sup&gt;, 내구성&lt;sup&gt;durability&lt;/sup&gt;, 유동성&lt;sup&gt;mobility&lt;/sup&gt;이 높아진다.&lt;/p&gt;

&lt;p&gt;SOLID의 앞선 원칙들을 이해하고 있다면 이 설명이 그리 어렵지 않을 것이다. 하지만 LSP와 OCP와의 구분이 다소 모호하고, 왜 역전&lt;sup&gt;inversion&lt;/sup&gt;이라는 용어로 이 원칙을 설명하고 있는지 궁금하다. 이 질문들에 답하기에 앞서 원칙을 제대로 이해하고 있는지 예제를 통해 먼저 확인해 보도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;예제를 통한 이해&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/의존관계-역전-원칙-DIP/그림1-복사-프로그램.png&quot; alt=&quot;four&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1. 복사 프로그램 (출처: &lt;a href=&quot;https://goo.gl/BVZajj&quot;&gt;https://goo.gl/BVZajj&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;위 그림은 &lt;i&gt;Copy&lt;/i&gt;라는 모듈이 &lt;i&gt;ReadKeyboard&lt;/i&gt;와 &lt;i&gt;WritePrinter&lt;/i&gt;라는 모듈에 의존하고 있음을 나타낸다. &lt;i&gt;Copy&lt;/i&gt;는 &lt;i&gt;ReadKeyboard&lt;/i&gt;의 반환 값을 &lt;i&gt;WriterPrinter&lt;/i&gt;에게 넘겨 주어 키보드로 읽은 내용을 프린터로 출력한다. 코드는 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadKeyboard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keyboard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WritePrinter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyboard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;무슨 문제가 있는 걸까? 요구사항을 잘 만족시키는 이 코드가 지금 당장 아무런 문제 없어 보일지 모르지만 2가지 잠재적 문제를 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;i&gt;Copy&lt;/i&gt;가 다루는 협력(또는 행위)을 다른 문맥&lt;sup&gt;context&lt;/sup&gt;에 재사용 할 수 없다.&lt;/li&gt;
  &lt;li&gt;입력이나 출력에 관한 새로운 행위가 추가되거나 제거될 때 &lt;i&gt;Copy&lt;/i&gt;가 함께 변경된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저, &lt;i&gt;Copy&lt;/i&gt;가 다루는 협력을 다른 문맥에 재사용 할 수 없다는 문제부터 이야기 해보자. 여기서 오해 하지 말아야 할 것은 &lt;i&gt;ReadKeyboard&lt;/i&gt;나 &lt;i&gt;WritePrinter&lt;/i&gt;는 충분히 재사용 가능하다는 것이다. &lt;i&gt;ReadKeyboard&lt;/i&gt;는 키보드 입력에 관한 것을 캡슐화 해 두었기 때문에 이러한 입력이 필요한 곳에 이 객체를 다시 사용할 수 있다. &lt;i&gt;WritePrinter&lt;/i&gt;도 마찬가지이다. 다만, 여기서 재사용이 어려운 것은 &lt;i&gt;Copy&lt;/i&gt;가 다루는 협력이다. &lt;i&gt;Copy&lt;/i&gt;는 다른 모듈로부터 입력을 받고 이를 출력하는 모듈로 넘긴다. 여기서 ‘입력 모듈의 결과를 출력 모듈로 넘긴다’라는 이 협력은 오직 &lt;i&gt;ReadKeyboard&lt;/i&gt;와 &lt;i&gt;WritePrinter&lt;/i&gt;에게만 적용 가능하다. 만약 이러한 입출력 처리가 &lt;i&gt;ReadMouse&lt;/i&gt;나 &lt;i&gt;WriteFax&lt;/i&gt; 등의 객체에서도 발생한다면, 기존 &lt;i&gt;Copy&lt;/i&gt; 대신 &lt;i&gt;MouseFaxCopy&lt;/i&gt;라는 새로운 객체를 만들어야 할지도 모른다.&lt;/p&gt;

&lt;p&gt;다음으로, 입출력에 관한 행위가 추가되거나 제거될 때 &lt;i&gt;Copy&lt;/i&gt;가 함께 변경되는 문제를 살펴보자. 만약 키보드 입력의 결과를 파일에도 출력해야 한다면 어떻게 해야 할까? &lt;i&gt;Copy&lt;/i&gt;가 &lt;i&gt;WritePrinter&lt;/i&gt;에 여전히 의존하고 있는 경우라면, 다음과 같이 코드를 작성할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadKeyboard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keyboard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WritePrinter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WriteFile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isPrinterWrite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isPrinterWrite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyboard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyboard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 상태에서 새로운 출력 객체가 또 다시 추가되야 한다면? 새로운 입력 객체가 생긴다면? 기존 &lt;i&gt;PrinterWrite&lt;/i&gt;가 없어진다면? 위 코드는 이러한 변화가 일어날 때 마다 &lt;i&gt;Copy&lt;/i&gt;가 함께 수정되는 문제를 지니고 있다. 수정이 한 곳에서만 일어난다면 그나마 다행이다. 함께 변경되야 하는 부분이 언제 어디에 추가 될지는 예측하기 어렵다.&lt;/p&gt;

&lt;p&gt;왜 이런 문제가 발생했을까? &lt;i&gt;Copy&lt;/i&gt;가 너무 세부적인 것들에 의존하기 때문이다. &lt;i&gt;Copy&lt;/i&gt;를 아래 그림처럼 추상화 된 것에 의존하도록 변경해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/의존관계-역전-원칙-DIP/그림2-추상화된-것에-의존하는-Copy-모듈.png&quot; alt=&quot;four&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림2. 추상화된 것에 의존하는 &lt;i&gt;Copy&lt;/i&gt; 모듈 (출처: &lt;a href=&quot;https://goo.gl/BVZajj&quot;&gt;https://goo.gl/BVZajj&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;SOLID에 대한 앞선 글들을 읽어 보았다면 개선된 코드를 충분히 예상할 수 있을 것이다. 코드는 생략하고 무엇이 좋아졌는지를 이야기 해보자. 우선, &lt;i&gt;Copy&lt;/i&gt;의 행위를 다른 문맥, 즉 다른 객체들과의 관계에도 적용할 수 있다. 예를 들어, &lt;i&gt;Copy&lt;/i&gt;의 행위를 &lt;i&gt;KeyboardReader&lt;/i&gt;와 &lt;i&gt;PrinterWriter&lt;/i&gt; 대신 &lt;i&gt;VoiceReader&lt;/i&gt;(&lt;i&gt;Reader&lt;/i&gt; 구현체)와 &lt;i&gt;DisplayWriter&lt;/i&gt;(&lt;i&gt;Writer&lt;/i&gt; 구현체)에도 그대로 적용할 수 있다. 입력과 출력의 협력을 다른 객체들에 재사용할 수 있는 것이다. 또한 &lt;i&gt;Copy&lt;/i&gt;는 &lt;i&gt;Reader&lt;/i&gt;와 &lt;i&gt;Writer&lt;/i&gt;라는 추상화에 의존하므로, 이들의 구현체(세부 사항)가 추가되거나 변경될 때 더 이상 직접적인 영향을 받지 않게 된다.&lt;/p&gt;

&lt;h2 id=&quot;lsp-ocp-&quot;&gt;LSP, OCP와의 관계&lt;/h2&gt;

&lt;p&gt;DIP를 보고 나면 ‘LSP, OCP와 무엇이 다른가’라는 의문이 생길 수 있다. 따라서 이들과의 관계를 정리해 볼 필요가 있다. 우선 OCP와 LSP의 정의를 떠올려 보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OCP: 확장에 열려 있고 수정에 닫혀 있어야 한다.&lt;/li&gt;
  &lt;li&gt;LSP: 기반 클래스의 사용자는 그 기반 클래스의 파생 클래스를 알지 못해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우선, OCP는 DIP가 가져오는 효과라고 할 수 있다. 추상화에 의존하는 DIP를 적용함으로써, 확장에는 열려 있고 수정에는 닫혀 있는 OCP를 이룰 수 있기 때문이다. LSP와 OCP의 관계도 유사하다. LSP가 깨지면 OCP도 깨진다. 마지막으로 DIP와 LSP의 관계는 어떠한가? 이를 정의하는 것이 쉽지는 않지만 개인적으로 이렇게 생각한다. DIP는 기존의 의존 관계를 뒤집으라는 메시지 전달 의도가 강하고, LSP는 이러한 구조에서 저지르기 쉬운 오류를 짚어 주는 느낌이다. 또한 DIP가 LSP에 비해 좀 더 포괄적이고 일반화 된 관계로 보이기도 한다. 참고로, 로버트 마틴은 LSP, OCP를 적용하여 얻어진 구조를 일반화 할 수 있고 이를 DIP라고 부른다고 했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The structure that results from rigorous use of these principles can be generalized into a principle all by itself. I call it “The Dependency Inversion Principle” (DIP).&lt;/p&gt;

  &lt;p&gt;– &lt;cite&gt;Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz/view&quot;&gt;ISP: The Dependency Inversion Principle&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;왜 역전인가?&lt;/h2&gt;

&lt;p&gt;DIP를 이해하고 난 후에도, 왜 역전&lt;sup&gt;inversion&lt;/sup&gt;이라는 용어가 사용 되었는지는 여전히 의문이다. 이에 대해 로버트 마틴은 이렇게 이야기한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;One might question why I use the word “inversion”. Frankly, it is because more traditional software development methods, such as Structured Analysis and Design, tend to create software structures in which high level modules depend upon low level modules, and in which abstractions depend upon details.&lt;/p&gt;

  &lt;p&gt;– &lt;cite&gt;Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz/view&quot;&gt;ISP: The Dependency Inversion Principle&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요약하면, 상위 수준의 모듈이 하위 수준의 모듈에 의존하는 경향이 기존의 전통적 개발 방식에서 두드러지기 때문이라고 한다. 이러한 구조를 뒤집으라는 의도에서 역전&lt;sup&gt;inversion&lt;/sup&gt;이라는 용어가 사용된 것이다. 하지만 처음부터 객체 지향 언어와 설계를 경험한 사람들에게 이 용어가 과연 이해를 돕는가에 대해서는 의문이다. 제어의 역전&lt;sup&gt;Inversion of Control&lt;/sup&gt;이라는 용어에 익숙하다면 얘기가 다르겠지만 말이다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;마무리 하며&lt;/h2&gt;

&lt;p&gt;그 동안 다소 부족한 글이긴 했지만 SOLID의 다섯 가지 원칙 모두를 알아보았다. 지금까지 SOLID가 무엇인지 그 자체에 집중 했었다면, 이제는 다시 SOLID가 해결하려는 문제가 뭐였는지를 되돌아 볼 필요가 있다. 이는 결국 OOP의 의존성 관리에 관한 것이었고 재사용성&lt;sup&gt;reusability&lt;/sup&gt;, 강건함&lt;sup&gt;robustness&lt;/sup&gt;, 유연함&lt;sup&gt;flexibility&lt;/sup&gt;을 위한 노력이었다. 하지만 소프트웨어 개발에 있어 이 가치가 절대적인 것은 아니며, 이 가치를 위한 노력이 SOLID만 존재하는 것도 아니다. 우리가 지금 해결하려는 문제가 무엇인지 생각해야 하고 문제를 해결하기 위한 수단의 한 가지로 SOLID를 이해해야 한다. 적어도 SOLID를 통해 고민했던 내용들이 코드를 바라보는 힘을 길러주고 문제 해결을 위한 아이디어가 될 것임은 분명하다.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;참고 문헌&lt;/h2&gt;

&lt;p&gt;[1] Robert Martin. &lt;a href=&quot;https://goo.gl/BVZajj&quot;&gt;DIP: The Dependency Inversion Principle&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Jul 2016 08:00:50 +0900</pubDate>
        <link>//2016/07/18/%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8-%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8C%E1%85%A5%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</link>
        <guid isPermaLink="true">//2016/07/18/%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8-%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8C%E1%85%A5%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</guid>
      </item>
    
      <item>
        <title>인터페이스 분리 원칙 (ISP)</title>
        <description>&lt;p&gt;SOLID의 네 번째 원칙인 인터페이스 분리 원칙&lt;sup&gt;Interface Segregation Principle&lt;/sup&gt;에 대해 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;인터페이스 분리 원칙이란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;“CLIENTS SHOULD NOT BE FORCED TO DEPEND UPON INTERFACES THAT THEY DO NOT USE.”&lt;/p&gt;

  &lt;p&gt;– &lt;cite&gt;Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi/view&quot;&gt;ISP: The Interface Segregation Principle&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사용하지도 않는 인터페이스에 클라이언트가 의존해서는 안된다. 클라이언트 간의 의도치 않은 결합을 피하기 위해서이다. A라는 인터페이스가 있고 이를 사용하는 클라이언트 B, C가 있다고 해보자. A의 특정 메서드를 B가 사용하지만 C는 사용하지 않을 경우, 이 메서드가 변경될 때 마다 C는 자신과 상관 없는 이유로 영향을 받게 된다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;뚱뚱한 인터페이스&lt;/h2&gt;

&lt;p&gt;ISP를 간단한 예제와 함께 좀 더 살펴보려고 한다. 문을 열고 닫으며, 열림 여부를 확인할 수 있는 &lt;i&gt;Door&lt;/i&gt; 인터페이스가 있다. 만약, 일정 시간이 지났을 때 문이 자동으로 닫히게 하려면 어떻게 해야 할까? 한 가지 방법은 &lt;i&gt;TimerClient&lt;/i&gt;라는 인터페이스를 추가하고 &lt;i&gt;Door&lt;/i&gt;가 이를 구현하는 것이다. 아래 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/인터페이스-분리-원칙-ISP/그림1-fat-interface.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1. 뚱뚱한 인터페이스&lt;/p&gt;

&lt;p&gt;&lt;i&gt;Timer&lt;/i&gt;는 일정 시간이 지났음을 통지하기 위해 &lt;i&gt;TimerClient&lt;/i&gt; 인터페이스의 &lt;i&gt;timeout&lt;/i&gt;을 호출한다. 호출 대상은 &lt;i&gt;register&lt;/i&gt; 메서드로 등록하며, 코드는 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimerClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timerClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimerClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
   &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimerClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDoorOpen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimedDoor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDoorOpen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locked&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;요구 사항은 만족시켰지만 몇 가지 문제점들이 보인다. 우선, &lt;i&gt;TimerClient&lt;/i&gt;의 상속은 오로지 타이머 관련 구현체 만을 위한 노력이다. 타이머 기능이 필요 없는 구현체에서는 &lt;i&gt;timeout&lt;/i&gt; 구현이 무의미 하며 오히려 부담이 될 뿐이다. 이 부담을 덜기 위해 상위 클래스를 만들고 아무 것도 하지 않는 구현을 기본적으로 제공한다 해도 LSP(리스코프 치환 원칙)를 위반하게 된다. 무엇보다도, 이런 식의 상속이 계속된다면 &lt;i&gt;Door&lt;/i&gt;는 머지 않아 뚱뚱한 인터페이스&lt;sup&gt;fat interface&lt;/sup&gt;가 될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;supseparation-through-delegationsup&quot;&gt;위임을 통한 분리&lt;sup&gt;Separation through Delegation&lt;/sup&gt;&lt;/h2&gt;

&lt;p&gt;위 문제를 해결하기 위한 한 가지 방법은 위임이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/인터페이스-분리-원칙-ISP/그림2-separation-through-delegation.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2. 위임을 통한 분리&lt;/p&gt;

&lt;p&gt;&lt;i&gt;DoorTimerAdapter&lt;/i&gt;는 &lt;i&gt;TimerClient&lt;/i&gt;의 구현체로써 &lt;i&gt;Timer&lt;/i&gt;로부터 타임아웃을 통지 받는다. 이 때 통지 받은 메시지는 &lt;i&gt;TimedDoor&lt;/i&gt;에게 바로 위임된다. 위임을 통해 기존 인터페이스의 수정 없이 새로운 인터페이스를 지원 한다는 점에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern#Object_Adapter_pattern&quot;&gt;객체 형식의 어댑터 패턴&lt;/a&gt;이다.&lt;/p&gt;

&lt;p&gt;코드는 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DoorTimerAdapter&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimerClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;door&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoorTimerAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;door&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;door&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;door&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;door&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 &lt;i&gt;Door&lt;/i&gt;의 클라이언트와 &lt;i&gt;Timer&lt;/i&gt; 간의 결합은 사라졌다. 게다가 기존 &lt;i&gt;TimedDoor&lt;/i&gt;를 변경할 필요가 없으며, &lt;i&gt;Timer&lt;/i&gt;의 어떠한 변경에도 &lt;i&gt;Door&lt;/i&gt;의 사용자는 영향 받지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;supseparation-through-multiple-interfacesup&quot;&gt;다중 인터페이스를 통한 분리&lt;sup&gt;separation through Multiple Interface&lt;/sup&gt;&lt;/h2&gt;

&lt;p&gt;또 다른 해결책으로 다중 인터페이스 방식이 있다. 이는 &lt;i&gt;TimedDoor&lt;/i&gt;가 &lt;i&gt;Door&lt;/i&gt;와 &lt;i&gt;TimerClient&lt;/i&gt; 모두를 구현하는 것이다. 이렇게 하면 서로 다른 클라이언트가 &lt;i&gt;TimedDoor&lt;/i&gt;에 의존하지 않으면서도 &lt;i&gt;TimedDoor&lt;/i&gt;를 사용할 수 있다. 인터페이스가 분리 되어 있으므로 인터페이스의 변경은 이를 사용하는 클라이언트에만 영향을 미친다. 또한 기존 &lt;i&gt;Door&lt;/i&gt;의 구현체들이 &lt;i&gt;TimedDoor&lt;/i&gt;에만 필요한 &lt;i&gt;timeout&lt;/i&gt;을 일일이 구현하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/인터페이스-분리-원칙-ISP/그림3-separation-through-Multiple-Interface.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위임을 통한 분리와는 어떤 차이가 있을까? 기존 코드의 변경 없이 새로운 방식의 커뮤니케이션을 지원하므로 어댑터 패턴인 것은 동일하지만, 클래스에 새로운 인터페이스를 추가했다는 점에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern#Class_Adapter_pattern&quot;&gt;클래스 형식의 어댑터 패턴&lt;/a&gt;이다. 따라서 객체 형식의 어댑터와 차이점이 무엇인지 생각해 보면 된다. 클래스 형식의 객체 형식 대비 장단점은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타임아웃 등록을 위한 별도의 객체 생성이 필요 없다.&lt;/li&gt;
  &lt;li&gt;단지 위임만을 수행하는 코드 작성이 필요 없다.&lt;/li&gt;
  &lt;li&gt;다른 &lt;i&gt;Door&lt;/i&gt; 구현체가 &lt;i&gt;TimerClient&lt;/i&gt;가 되어야 하는 경우 &lt;i&gt;timeout&lt;/i&gt;을 일일이 구현해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;TimedDoor&lt;/i&gt;의 인스턴스화 시 &lt;i&gt;Door&lt;/i&gt;의 구현부와 &lt;i&gt;TimerClient&lt;/i&gt; 구현부가 항상 생명 주기를 함께 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;참고 문헌&lt;/h2&gt;

&lt;p&gt;[1] Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi/view&quot;&gt;ISP: The Interface Segregation Principle&lt;/a&gt;&lt;br /&gt;
[2] wikipedia. &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapter Pattern&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Jun 2016 01:30:50 +0900</pubDate>
        <link>//2016/06/11/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3-%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</link>
        <guid isPermaLink="true">//2016/06/11/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3-%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</guid>
      </item>
    
      <item>
        <title>리스코프 치환 원칙 (LSP)</title>
        <description>&lt;p&gt;SOLID의 세 번째 원칙인 리스코프 치환 원칙&lt;sup&gt;Liskov substitution principle&lt;/sup&gt;에 대해 알아보도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;리스코프 치환 원칙이란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;“FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT.”&lt;/p&gt;

  &lt;p&gt;– &lt;cite&gt;Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh/view&quot;&gt;LSP: The Liskov Substitution Principle&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;기반 클래스&lt;sup&gt;base class&lt;/sup&gt;의 사용자는 파생 클래스&lt;sup&gt;derived class&lt;/sup&gt;의 존재를 몰라도 기반 클래스를 사용할 수 있어야 한다. LSP를 위반한다는 것은 기반 클래스를 참조하면서 파생 클래스들에 대해서도 알고 있는 것이다. 이런 코드는 파생 클래스들이 추가될 때 마다 수정될 가능성이 높다. 즉, 수정에 닫혀 있지 못한 &lt;a href=&quot;&quot;&gt;OCP&lt;/a&gt; 위반이 된다.&lt;/p&gt;

&lt;p&gt;이를 설명하는 여러 예제가 있지만 사각형과 정사각형 이야기가 가장 흥미롭다. 아래 그림을 먼저 보도록 하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/리스코프-치환-원칙-LSP/그림1-ISA.png&quot; alt=&quot;two&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1. 사각형을 상속하는 정사각형&lt;/p&gt;

&lt;p&gt;‘정사각형은 사각형이다’라고 할 수 있으므로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Is-a&quot;&gt;ISA 관계&lt;/a&gt;가 성립하는 것 처럼 보인다. 따라서 그림의 상속 관계도 자연스러워 보인다. 하지만 코드와 함께 살펴 보면 이상한 부분들이 보이기 시작한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rectangle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Getter&lt;/span&gt;
   &lt;span class=&quot;nd&quot;&gt;@Setter&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Getter&lt;/span&gt;
   &lt;span class=&quot;nd&quot;&gt;@Setter&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Square&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rectangle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드는 넓이와 높이 속성을 가진 &lt;i&gt;Rectangle&lt;/i&gt;을 &lt;i&gt;Square&lt;/i&gt;가 상속하도록 하고 있다. 그런데, &lt;i&gt;Square&lt;/i&gt;가 상속하는 속성과 행위가 모두 필요한 걸까? 정사각형은 넓이와 높이가 동일하기 때문에 이는 생각해 볼 일이다. 우선 메모리 사용 측면에서 비효율이다. &lt;i&gt;Square&lt;/i&gt; 인스턴스가 생성될 때 마다 매번 2개 필드를 위한 메모리가 사용되기 때문이다. 두 번째로, 코드를 읽는 사람에게 혼란을 야기할 수 있다. “정사각형은 가로 세로가 동일한데 왜 필드가 2개이고 넓이와 높이를 지정하는 메서드가 각각 존재하는 건가?” 자칫 &lt;i&gt;width&lt;/i&gt;와 &lt;i&gt;height&lt;/i&gt;가 서로 달라지는 오류를 범할 수도 있다. &lt;i&gt;setWidth&lt;/i&gt;와 &lt;i&gt;setHeight&lt;/i&gt;를 오버라이드 해서 각 메서드 호출 시 마다 &lt;i&gt;width&lt;/i&gt;와 &lt;i&gt;height&lt;/i&gt;를 항상 동일하게 맞춰준다고 해도 코드의 사용자에게 주는 혼란은 여전하다. 아래 코드 처럼 말이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inconsistency&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rectangle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setHeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setWidth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getWidth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;메모리 비효율과 읽기 혼란을 무시한다고 해도 다른 문제가 남아 있다. &lt;i&gt;Rectangle&lt;/i&gt;의 사용자가 &lt;i&gt;Square&lt;/i&gt;의 존재를 알아야 한다는 것이다. 이 경우 다음과 같은 코드가 만들어 질 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ocpViolation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rectangle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setHeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setWidth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

   &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getWidth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Square&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;기존의 &lt;i&gt;inconsistency&lt;/i&gt; 메서드는 &lt;i&gt;Rectangleㅇ&lt;/i&gt; 객체를 참조하고 있지만 이 객체가 &lt;i&gt;Square&lt;/i&gt;(&lt;i&gt;Rectangle&lt;/i&gt;의 파생 클래스)의 객체일 때는 기대한 대로 동작하지 않는다. 그래서 &lt;i&gt;ocpViolation&lt;/i&gt; 메서드 처럼 별도의 처리가 필요하게 되고, 결국 ‘기반 클래스를 참조하면서 파생 클래스들에 대해서도 알고 있는’ LSP 위반이 된다. 이런 식의 &lt;i&gt;Rectangle&lt;/i&gt; 파생 클래스가 추가될 때 마다 ocpViolation도 함께 수정해 주어야 하므로 OCP를 위반하게 된다.&lt;/p&gt;

&lt;p&gt;파생 클래스들은 언제든지 기반 클래스로 치환&lt;sup&gt;substitution&lt;/sup&gt; 될 수 있어야 하며, 그러기 위해서 모든 파생 클래스들은 기반 클래스의 클라이언트 코드들이 기반 클래스에게 기대하는 것을 반드시 따라야만 한다. 이를 통해 기반 클래스들에 의존하는 코드들이 재사용 가능해지고 파생 클래스들의 변경에 영향 받지 않을 수 있게 된다. 이는 OCP가 추구하는 바 그대로이며, 이런 측면에서 LSP는 OCP를 따르기 위한 수단으로 보여지기도 한다.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;*작성된 코드 전체는 &lt;a href=&quot;https://github.com/codehumane/codehumane/tree/master/design-java/src/main/java/solid/lsp&quot;&gt;여기&lt;/a&gt;서 확인할 수 있습니다.&lt;/i&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;정사각형은 사각형인가?&lt;/h2&gt;

&lt;p&gt;정사각형은 사각형이 맞다. 하지만 &lt;i&gt;Square&lt;/i&gt;와 &lt;i&gt;Rectangle&lt;/i&gt; 클래스는 ISA 관계가 성립하지 않는다. &lt;i&gt;Square&lt;/i&gt; 객체의 행위가 &lt;i&gt;Rectangle&lt;/i&gt;의 그것과 상이하기 때문이다. &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/concepts/object.html&quot;&gt;상태와 행위를 가지는 것이 객체&lt;/a&gt;이고 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/concepts/class.html&quot;&gt;클래스는 이 객체의 행위를 구현한 템플릿&lt;sup&gt;template&lt;/sup&gt;&lt;/a&gt; 임을 생각할 때 &lt;i&gt;Square&lt;/i&gt;는 &lt;i&gt;Rectangle&lt;/i&gt;이 아니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;참고 문헌&lt;/h2&gt;

&lt;p&gt;[1] Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh/view&quot;&gt;LSP: The Liskov Substitution Principle.&lt;/a&gt; &lt;br /&gt;
[2] &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/concepts/object.html&quot;&gt;What is Object?&lt;/a&gt; &lt;br /&gt;
[3] &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/concepts/class.html&quot;&gt;What is Class?&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;관련 문서&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;/2016/04/17/SOLID-개요&quot;&gt;SOLID 개요&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&quot;/2016/05/01/단일-책임-원칙&quot;&gt;단일 책임 원칙 SRP&lt;/a&gt;&lt;br /&gt;
[3] &lt;a href=&quot;/2016/05/04/개방-폐쇄-원칙&quot;&gt;개방 폐쇄 법칙 OCP&lt;/a&gt;&lt;br /&gt;
[4] &lt;a href=&quot;/2016/06/03/리스코프-치환-원칙&quot;&gt;리스코프 치환 법칙 LSP&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Jun 2016 05:01:18 +0900</pubDate>
        <link>//2016/06/03/%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3-%E1%84%8E%E1%85%B5%E1%84%92%E1%85%AA%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</link>
        <guid isPermaLink="true">//2016/06/03/%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3-%E1%84%8E%E1%85%B5%E1%84%92%E1%85%AA%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</guid>
      </item>
    
      <item>
        <title>개방 폐쇄 원칙 (OCP)</title>
        <description>&lt;p&gt;SOLID 두 번째 단어인 개방 폐쇄 원칙&lt;sup&gt;Open-Closed Principle&lt;/sup&gt;에 대해 알아보도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;개방 폐쇄 원칙이란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;SOFTWARE ENTITIES (CLASSES, MODULES, FUNCTIONS, ETC.) SHOULD BE OPEN FOR EXTENSION, BUT CLOSED FOR MODIFICATION.&lt;/p&gt;

  &lt;p&gt;– &lt;cite&gt;Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view&quot;&gt;OCP: The Open-Closed Principle.&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어떤 변경 사항이 의존하는 모듈 들에 연속적으로 영향을 미친다면, 이는 깨지기 쉽고&lt;sup&gt;fragile&lt;/sup&gt;, 경직되고&lt;sup&gt;rigid&lt;/sup&gt;, 예측할 수&lt;sup&gt;unpredictable&lt;/sup&gt; 없으며, 재사용 불가능한&lt;sup&gt;unreusable&lt;/sup&gt; 디자인이다. OCP는 이러한 문제를 해결하기 위한 방법 중 하나이며, OCP를 따르는 모듈은 다음의 두 가지를 만족시킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;확장에 열려 있음&lt;sup&gt;Open For Extension&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;수정에 닫혀 있음&lt;sup&gt;Closed for Modification&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;요구 사항이 변경될 때 새로운 코드를 추가함으로써 행위를 확장해야지, 이미 동작하고 있는 기존 코드를 변경해서는 안된다는 이야기이다. 서로 모순되는 것 처럼 보이는 이 두 가지 속성은 추상화를 통해 만족시킬 수 있다. 특정 객체의 행위가 필요할 때는 인터페이스로 소통하고, 행위 추가시에는 구현체를 추가하는 것이다. 인터페이스는 상대적으로 잘 변하지 않으므로 수정에는 닫혀 있고, 구현체는 얼마든지 추가할 수 있으므로 확장에는 열려 있을 수 있다.&lt;/p&gt;

&lt;p&gt;간단한 예제를 통해 좀 더 생각해 보도록 하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/개방-폐쇄-원칙-OCP/그림1-확장에-닫힌-구조.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1. 확장에 닫힌 구조&lt;/p&gt;

&lt;p&gt;위 그림에서 Drawer는 도형을 화면에 그리는 역할을 담당하며, 대상이 되는 도형은 Rectangle과 Circle 클래스이다. 이를 코드로 표현하면 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Drawer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shapes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;shapes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getShapeType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;CIRCLE:&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;circle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;circle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RECTANGLE:&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;Rectangle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShapeType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;CIRCLE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SQUARE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;ShapeType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getShapeType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShapeType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getShapeType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShapeType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CIRCLE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;circle-draw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rectangle&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShapeType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getShapeType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShapeType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;RECTANGLE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rectangle-draw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;만약 새로운 종류의 Shape이 추가되면 어디를 수정해야 할까? 우선 ShapeType의 값을 추가해야 하고, 새로운 Shape 구현체를 추가해야 하며, Drawer의 draw 메서드에 새로운 case를 선언해야 한다. Shape이 추가될 때 마다 이 작업은 반복된다. 이 코드는 그나마 단순하지만, 실제 세상에서는 switch나 if/else를 찾느라 고생 좀 해야 할지도 모른다.&lt;/p&gt;

&lt;p&gt;이런 문제를 해결하기 위한 구조의 그림은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/개방-폐쇄-원칙-OCP/그림2-확장에-열린-구조.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2. 확장에 열린 구조&lt;/p&gt;

&lt;p&gt;코드는 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Drawer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shapes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;shapes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;circle-draw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rectangle&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rectangle-draw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;행위 확장시에는 Shape 구현체를 추가하면 되므로 열린 상태가 되고, Drawer 입장에서는 행위 추가로 인한 수정이 필요 없으므로 닫힌 상태가 된다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;얼마나 닫혀 있을 수 있을까?&lt;/h2&gt;

&lt;p&gt;만약 Shape 인터페이스에 메서드가 추가되면 어떠한가? 혹은 Circle과 Rectangle을 동시에 그릴 수 없다는 제약이 생긴다면? 기존 Shape 구현체들을 수정하거나 Drawer의 메서드를 수정해야 할지도 모른다. 닫혀 있던 부분들이 더 이상 닫혀 있지 않게 되는 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In general, no matter how “closed” a module is, there will always be some kind of change against which it is not closed.&lt;/p&gt;

  &lt;p&gt;Since closure cannot be complete, it must be strategic. That is, the designer must choose the kinds of changes against which to close his design. This takes a certain amount of prescience derived from experience.&lt;/p&gt;

  &lt;p&gt;&lt;cite&gt;– Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view&quot;&gt;OCP: The Open-Closed Principle.&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모듈의 닫힘 정도와 관계 없이, 닫혀 있을 수 없는 변경은 항상 존재한다고 한다. 이에 따라 전략적 닫힘&lt;sup&gt;strategic closure&lt;/sup&gt;이 필요하게 되는데, 이는 결국 어떤 부분을 변경에 대해 닫혀 있도록 할지 결정해야 한다는 이야기이다. 이 결정은 직관에 따를 수도 있고 경험 또는 데이터 등에 기반할 수도 있겠다.&lt;/p&gt;

&lt;p&gt;로버트 마틴의 글에서는 이를 설명하기 위해 Circle 보다 Rectangle을 먼저 그려야 한다는 제약을 Drawer에 추가한다. 이를 만족시키기 위한 방법으로는 2가지가 언급되는데, 각각은 서로 다른 곳에서 열린 변경이 발생한다. 첫 번째는 Drawer를 수정에 닫혀 있도록 하는 방법이다. 이는 Shape 구현체들이 스스로 우선순위를 결정하게 함으로써 가능하다. Java로 구현하고자 한다면 Shape 구현체들이 Comparable을 구현하게 하고, Drawer에서는 Collections.sort를 이용할 수 있겠다.&lt;/p&gt;

&lt;p&gt;하지만 Shape이 추가되거나 Shape에 대한 정렬 정책이 바뀔 때 마다, 각 Shape 구현체들에 대한 수정이 불가피하게 된다. Shape 구현체들이 수정에 대해 닫혀 있고자 한다면, Shape 구현체들의 우선순위를 담은 자료 구조형 클래스를 생각해 볼 수 있다. 이 우선순위를 기반으로 Shape 구현체들을 정렬하는 메서드만 만들어 두면, Shape이 추가되거나 정렬 정책 변경 시에 이 자료 구조 클래스만 수정해 주면 된다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;좀 더 확장 해 보기&lt;/h2&gt;

&lt;p&gt;만약 Shape의 타입과 상관 없는 정렬을 지원해야 한다면 어떨까? 닫힘에 대해 좀 더 생각해 볼 이슈라면서 로버트 마틴이 던지는 질문이다. 다만, OrderedObject라는 추상화(OrderedShape이라는 클래스가 Shape과 OrderedShape로부터 파생)를 이용하라고 한다. 코드나 다이어그램 등 더 이상의 설명은 없어 정확히 예측은 어렵지만, 개인적으로 이런 코드를 이야기하고 있는 게 아닌가 싶다. 작성된 코드는 아래 링크에서 확인할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/codehumane/codehumane/tree/master/design-java/src/main/java/solid/ocp/more&quot;&gt;Shape 타입과 상관 없는 대상에 대해서도 정렬 지원&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/codehumane/codehumane/blob/master/design-java/src/test/java/solid/ocp/more/Client.java&quot;&gt;작성된 모듈을 사용하는 클라이언트 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;생각해 볼 거리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;전략적 닫힘을 고려할 때, Factory Pattern은 어떠한가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;참고 문헌&lt;/h2&gt;

&lt;p&gt;[1] Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view&quot;&gt;OCP: The Open-Closed Principle.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;관련 문서&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;/2016/04/17/SOLID-개요&quot;&gt;SOLID 개요&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&quot;/2016/05/01/단일-책임-원칙&quot;&gt;단일 책임 원칙 SRP&lt;/a&gt;&lt;br /&gt;
[3] &lt;a href=&quot;/2016/05/04/개방-폐쇄-원칙&quot;&gt;개방 폐쇄 법칙 OCP&lt;/a&gt;&lt;br /&gt;
[4] &lt;a href=&quot;/2016/06/03/리스코프-치환-원칙&quot;&gt;리스코프 치환 법칙 LSP&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 04 May 2016 21:32:18 +0900</pubDate>
        <link>//2016/05/04/%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%BC-%E1%84%91%E1%85%A8%E1%84%89%E1%85%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</link>
        <guid isPermaLink="true">//2016/05/04/%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%BC-%E1%84%91%E1%85%A8%E1%84%89%E1%85%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</guid>
      </item>
    
      <item>
        <title>단일 책임 원칙 (SRP)</title>
        <description>&lt;p&gt;SOLID 가장 첫 번째 단어인 단일 책임 원칙&lt;sup&gt;Single Responsibility Principle&lt;/sup&gt;에 대해 알아보도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;단일 책임 원칙이란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A CLASS SHOULD HAVE ONLY ONE REASON TO CHANGE.&lt;/p&gt;

  &lt;p&gt;– &lt;cite&gt;Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/view&quot;&gt;SRP: The Single Responsibility Principle.&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;클래스는 변경에 대한 한 가지 이유만을 가져야 한다. 다양한 이유로 클래스가 변경 되어서는 안된다. 예를 들어, 어떤 클래스가 비즈니스 규칙과 인프라스트럭처&lt;sup&gt;infrastructure&lt;/sup&gt;(데이터 영속성 관리 등 비즈니스 규칙에 비해 변경 가능성이 낮은) 변화에 따라 함께 변경된다면 클래스는 분리될 필요가 있는 것이다. 변경에 대한 이유&lt;sup&gt;a reason for change&lt;/sup&gt; 그리고 변경의 축&lt;sup&gt;an axis of change&lt;/sup&gt;이 바로 책임&lt;sup&gt;responsibility&lt;/sup&gt;이며, 단일 책임 원칙의 핵심이다.&lt;/p&gt;

&lt;p&gt;책임이 분리되어야 하는 이유를 간단한 예제로 함께 설명해 보도록 하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/단일-책임-원칙-SPR/그림1-한-가지-이상의-책임.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1. 한 가지 이상의 책임 (출처: &lt;a href=&quot;https://goo.gl/HbixP9&quot;&gt;https://goo.gl/HbixP9&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;위 그림에서 Rectangle은 두 가지 책임을 가지고 있다. 하나는 스크린에 사각형을 그리는 렌더링&lt;sup&gt;rendering&lt;/sup&gt;, 하나는 사각형의 넓이를 구하는 수학적 책임이다. 이 설계가 가져오는 문제는 2가지이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ComputationalGeometryApplication이 GUI를 포함해야 한다.&lt;/li&gt;
  &lt;li&gt;GraphicalApplication으로 인한 Rectangle의 변경이 ComputationalGeometryApplication에도 영향을 준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;왜 ComputationalGeometryApplication는 GUI를 사용하지도 않는데 GUI를 포함해야 할까? 또, ComputationalGeometryApplication와 상관 없는 기능으로 Rectangle이 변경되었는데 왜 다시 테스트를 받아야 하는가? 테스트해야 한다는 사실을 모를 경우 예상치 못한 문제가 생길 수도 있는 노릇이다. 불필요한 의존성은 예상치 못한 비용을 불러온다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/단일-책임-원칙-SPR/그림2-분리된-책임.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2. 분리된 책임 (출처: &lt;a href=&quot;https://goo.gl/HbixP9&quot;&gt;https://goo.gl/HbixP9&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;위 그림은 책임을 분리한 결과이고, 이제 렌더링 관련된 기능이 ComputationalGeometryApplication에 더 이상 영향을 주지 않는다. 책임의 결합&lt;sup&gt;coupling&lt;/sup&gt;은 깨지기 쉬운 디자인이다. 변경의 영향 범위를 파악하기가 어려워지고, 예상치 못한 곳에 문제를 일으킨다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;책임의 경계는 어디까지인가?&lt;/h2&gt;

&lt;p&gt;아래 인터페이스를 통해 책임의 경계에 대해 좀 더 생각해 보도록 하자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Modem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hangup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Recv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Modem이라는 클래스에는 2가지 책임이 있는 것 처럼 보인다. 하나는 연결 관리(Dial, Hangup)이고, 다른 하나는 데이터 통신(Send, Recv)이다. 그런데 정말 이 책임이 분리되어야 할까?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;That depends upon how the application is changing. If the application changes in ways that affect the signature of the connection functions, then the design will smell of Rigidity because the classes that call send and read will have to be recompiled and redeployed more often than we like.&lt;/p&gt;

  &lt;p&gt;If, on the other hand, the application is not changing in ways that cause the the two responsibilities to change at different times, then there is no need to separate them. Indeed, separating them would smell of Needless Complexity.&lt;/p&gt;

  &lt;p&gt;– &lt;cite&gt;Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/view&quot;&gt;SRP: The Single Responsibility Principle.&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;로버트 마틴은 “어플리케이션이 어떻게 변하느냐에 따라 다르다”라고 이야기 한다. 만약 데이터 통신과 상관 없이 연결 관리 부분만 변경된다면 이는 경직성&lt;sup&gt;rigidity&lt;/sup&gt;이고, 함께 변경되는 데도 불구하고 분리한다면 불필요한 복잡도&lt;sup&gt;Needless Complexity&lt;/sup&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;생각해 볼 거리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;변화를 얼마나 예측할 수 있는가?&lt;/li&gt;
  &lt;li&gt;변경 이외에 책임을 정의하는 의미 있는 지표는 무엇인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;참고 문헌&lt;/h2&gt;

&lt;p&gt;[1] Robert Martin. &lt;a href=&quot;https://drive.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/view&quot;&gt;SRP: The Single Responsibility Principle.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;관련 문서&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;/2016/04/17/SOLID-개요&quot;&gt;SOLID 개요&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&quot;/2016/05/01/단일-책임-원칙&quot;&gt;단일 책임 원칙 SRP&lt;/a&gt;&lt;br /&gt;
[3] &lt;a href=&quot;/2016/05/04/개방-폐쇄-원칙&quot;&gt;개방 폐쇄 법칙 OCP&lt;/a&gt;&lt;br /&gt;
[4] &lt;a href=&quot;/2016/06/03/리스코프-치환-원칙&quot;&gt;리스코프 치환 법칙 LSP&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 01 May 2016 17:32:18 +0900</pubDate>
        <link>//2016/05/01/%E1%84%83%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%AF-%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</link>
        <guid isPermaLink="true">//2016/05/01/%E1%84%83%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%AF-%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8/</guid>
      </item>
    
      <item>
        <title>SOLID 개요</title>
        <description>&lt;p&gt;SOLID의 구체적인 이야기에 앞서 나쁜 디자인은 무엇이고, SOLID는 어떤 문제를 해결하려 하는지 살펴보도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;나쁜 디자인&lt;/h2&gt;

&lt;p&gt;로버트 마틴의 &lt;a href=&quot;https://drive.google.com/file/d/0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz/view&quot;&gt;The Dependency Inversion Principle 문서&lt;/a&gt;에서는 나쁜 디자인&lt;sup&gt;Bad Design&lt;/sup&gt;을 다음과 같이 정의하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A piece of software that fulfills its requirements and yet exhibits any or all of the following three traits has a bad design.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서 가리키는 3가지 특성은 다음과 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;It is hard to change because every change affects too many other parts of the system. (Rigidity)&lt;/li&gt;
    &lt;li&gt;When you make a change, unexpected parts of the system break. (Fragility)&lt;/li&gt;
    &lt;li&gt;It is hard to reuse in another application because it cannot be disentangled from the current application. (Immobility)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;변경 사항이 발생했을 때 다른 곳에 너무 많은 변경을 가져오거나(경직성&lt;sup&gt;rigidity&lt;/sup&gt;), 예측하지 못한 곳에서 문제가 생길 때(깨지기 쉬움&lt;sup&gt;fragility&lt;/sup&gt;), 혹은 현재 어플리케이션에서 분리해내기 어려워 다른 곳에서 재사용하기 어려운 것(부동성&lt;sup&gt;immobility&lt;/sup&gt;)을 가리킨다.&lt;/p&gt;

&lt;p&gt;여기서 주목할 만한 부분은 “요구사항을 충족하는&lt;sup&gt;fulfills its requirements&lt;/sup&gt;”이다. 아무리 좋은 설계를 가지고 있다고 하더라도 요구사항을 만족시키지 못한다면 가치를 전달할 수 없다. 언제나 잊지 말아야 할 부분이다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;객체 지향 설계의 5가지 원칙&lt;/h2&gt;

&lt;p&gt;단지 객체 지향 언어를 쓰는 것만으로는 경직성, 깨지기 쉬움, 부동성을 해결할 수 없다. 객체 지향 언어의 근간이 되는 가치들을 얻기 위해서는 여러 가지 노력이 필요한데, 그 중의 하나가 SOLID이다. 이는 로버트 마틴&lt;sup&gt;Robert Martin&lt;/sup&gt;이 2000년대 초에 명명한 다섯 가지 객체 지향 프로그래밍 및 설계 원칙을 줄여서 부르는 말이다(출처: &lt;a href=&quot;https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&quot;&gt;https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;로버트 마틴의 &lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot;&gt;OOD 원칙&lt;sup&gt;The Principle of OOD&lt;/sup&gt;&lt;/a&gt;에 따르면 이 다섯 가지 원칙이 특히 OOD의 의존성 관리 측면에 관한 것이라고 한다. 의존성 관리가 약할 경우 코드는 변경하기 어렵고, 깨지기 쉽고, 재사용하기 어렵다. 반대로, 의존성 관리가 잘 되면 코드는 유연&lt;sup&gt;flexible&lt;/sup&gt;하고 강건&lt;sup&gt;robust&lt;/sup&gt;하며, 재사용 하기 쉽다&lt;sup&gt;reusable&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;SOLID의 각 요소는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단일 책임 원칙&lt;sup&gt;Single Responsibility Principle&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;개방-폐쇄 원칙&lt;sup&gt;Open/closed principle&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;리스코프 치환 원칙&lt;sup&gt;Liskov substitution principle&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;인터페이스 분리 원칙&lt;sup&gt;Interface segregation principle&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;의존관계 역전 원칙&lt;sup&gt;Dependency inversion principle&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이어지는 글에서 하나씩 자세히 살펴보도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;관련 문서&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;/2016/04/17/SOLID-개요&quot;&gt;SOLID 개요&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&quot;/2016/05/01/단일-책임-원칙&quot;&gt;단일 책임 원칙 SRP&lt;/a&gt;&lt;br /&gt;
[3] &lt;a href=&quot;/2016/05/04/개방-폐쇄-원칙&quot;&gt;개방 폐쇄 법칙 OCP&lt;/a&gt;&lt;br /&gt;
[4] &lt;a href=&quot;/2016/06/03/리스코프-치환-원칙&quot;&gt;리스코프 치환 법칙 LSP&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Apr 2016 21:32:18 +0900</pubDate>
        <link>//2016/04/17/SOLID-%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/</link>
        <guid isPermaLink="true">//2016/04/17/SOLID-%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/</guid>
      </item>
    
      <item>
        <title>docker storage driver의 이해</title>
        <description>&lt;p&gt;docker의 storage driver를 파악하기 위해 docker 공식 문서를 살펴보았고 이를 간단한 의견과 함께 요약했다. 참고 문서의 링크는 다음의 2가지이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers&quot;&gt;Understand images, containers, and storage drivers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/userguide/storagedriver/selectadriver&quot;&gt;Select a storage driver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;layer&quot;&gt;Layer&lt;/h2&gt;

&lt;p&gt;가장 먼저 이미지와 컨테이너를 구성하는 layer가 소개 된다. 이미지는 여러 개의 읽기 전용&lt;sup&gt;read-only&lt;/sup&gt; 레이어로 이루어진 파일 시스템이며, 컨테이너가 실행될 때는 읽기 쓰기가 가능한 새로운 레이어가 이미지의 레이어 스택 최상단에 추가된다. 컨테이너가 수행되는 동안에 새로 추가되거나 수정된 데이터들은 이 쓰기 가능한 레이어에 기록되고, 컨테이너가 삭제되는 경우는 이 쓰기 가능한 레이어만 삭제되며 이미지의 레이어들은 그대로 남아 있게 된다.&lt;/p&gt;

&lt;p&gt;이 구조를 그림으로 보면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.docker.com/engine/userguide/storagedriver/images/container-layers.jpg&quot; alt=&quot;그림이 없는 경우 아래 URL을 참고하세요.&quot; title=&quot;Container based on the Ubuntu 15.04 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1. Container based on the Ubuntu 15.04 image (출처: &lt;a href=&quot;http://goo.gl/DhlZyD&quot;&gt;http://goo.gl/DhlZyD&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;도커의 storage driver는 바로 이러한 레이어들을 스택으로 관리하고 하나의 단일화된 뷰로 제공하는 역할을 수행한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Docker storage driver is responsible for stacking these layers and providing a single unified view.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 storage driver가 무엇이냐에 따라 이 작업들이 어떻게 이뤄지는 지가 결정된다.&lt;/p&gt;

&lt;h2 id=&quot;copy-on-write-strategy&quot;&gt;Copy-on-write strategy&lt;/h2&gt;

&lt;p&gt;도커 이미지와 컨테이너를 관리하는 두 가지 핵심 기술은 이미지 레이어 스택과 copy-on-write(CoW) 전략이라고 한다. 레이어에 대해서는 위에서 다루었고, 이제 CoW에 대해서 살펴볼 차례이다. 문서에서는 CoW에 대한 설명을 다음과 같이 하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In this strategy, system processes that need the same data share the same instance of that data rather than having their own copy. At some point, if one process needs to modify or write to the data, only then does the operating system make a copy of the data for that process to use. Only the process that needs to write has access to the data copy. All the other processes continue to use the original data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정리하면, 기본적으로 시스템 프로세스들끼리는 동일 데이터를 사용할 때, 데이터의 복사본이 아니라 데이터의 인스턴스를 공유한다. 데이터를 복사하는 경우는 특정 프로세스가 데이터를 수정하려고 할 때 이다. 이 데이터의 복사본은 데이터를 수정하려고 하는 프로세스에게만 접근 가능하다.&lt;/p&gt;

&lt;p&gt;도커는 이 CoW 전략을 통해 이미지의 디스크 사용 효율과 컨테이너 실행 속도를 높이는데, 디스크 효율성에 대해서는 아래 이미지를 보면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.docker.com/engine/userguide/storagedriver/images/saving-space.jpg&quot; alt=&quot;&quot; title=&quot;Image Layer Sharing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2. Image Layer Sharing (출처: &lt;a href=&quot;http://goo.gl/DhlZyD&quot;&gt;http://goo.gl/DhlZyD&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;그림에는 changed-ubuntu라는 이름의 이미지와 ubuntu:15.04라는 이름의 이미지가 있는데, changed-ubuntu는 베이스 이미지&lt;sup&gt;base image&lt;/sup&gt;를 ubuntu:15.04로 하는 이미지이다. 베이스 이미지가 가진 레이어는 공유를 하고(복사가 아니라), changed-ubuntu의 차이점만을 레이어 스택에 추가하고 있다. changed-ubuntu의 Dockerfile은 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;FROM ubuntu:15.04
RUN echo &quot;Hello world&quot; &amp;gt; /tmp/newfile&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;즉, changed-ubuntu의 레이어인 94e6b7d2c720는 RUN 수행 부분임을 알 수 있다. 참고로, 이러한 디스크 효율성은 이미지 빌드 시의 속도 향상으로 나타나기도 한다. Dockerfile의 문장들을 일일이 수행하는 게 아니라, 이미 존재하는 레이어가 있다면 이를 그대로 공유하도록 하는 것이다.&lt;/p&gt;

&lt;p&gt;다음은 컨테이너의 효율성과 성능에 관한 이야기인데, 먼저 아래 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.docker.com/engine/userguide/storagedriver/images/sharing-layers.jpg&quot; alt=&quot;&quot; title=&quot;Container Layer Sharing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 3. Container Layer Sharing (출처: &lt;a href=&quot;http://goo.gl/DhlZyD&quot;&gt;http://goo.gl/DhlZyD&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;컨테이너는 이미지의 레이어 스택 최상단에 새로운 쓰기 가능한 레이어를 추가하는 형태이므로, 여러개의 컨테이너가 실행되더라도 이미지의 레이어가 공유되어 공간 효율성이 높아진다. 또한, 컨테이너 실행 시 단지 얇고 쓰기 가능한 레이어&lt;sup&gt;thin and writable layer&lt;/sup&gt;만 추가하면 되므로 속도도 빠르다(컨테이너 실행 시 마다 매번 이미지의 레이어들을 복사해야 한다고 생각해 보라).&lt;/p&gt;

&lt;p&gt;한편, 이러한 구조로 인한 단점도 존재한다. 이미 존재하던 파일을 컨테이너가 수정할 때 storage driver의 copy-on-write 작업을 거치게 되고 이 때 성능 부하가 일어나는 것이다. 도커 문서에서는 이 성능 부하를 눈에 띌만한noticeable 이라는 수식어로 표현하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A copy-up operation can incur a noticeable performance overhead.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이러한 부하는 어떤 storage driver를 사용하냐에 따라 다르며, 따라서 어떤 storage driver를 사용할 것인지 알아두는 것은 중요해 보인다. 참고로, 많은 파일이나 레이어, 깊은 디렉토리 구조로 인한 부하는 이보다 더 크다는 이야기도 하고 있다. 다행히, 파일 수정 시의 copy-on-write는 최초 수정 시에만 발생하고 동일 파일에 대한 이후의 수정 시에는 이미 컨테이너에 있는 파일을 수정한다고 한다.&lt;/p&gt;

&lt;h2 id=&quot;storage-driver-&quot;&gt;storage driver의 역할&lt;/h2&gt;

&lt;p&gt;이미 storage driver의 역할에 대해서는 언급되었지만 다시 한 번 간단히 요약하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;레이어들을 스택으로 관리하고 하나의 단일화된 뷰 제공&lt;/li&gt;
  &lt;li&gt;레이어들을 copy-on-write 전략으로 관리
    &lt;ul&gt;
      &lt;li&gt;일반적으로 레이어들을 복사가 아닌 공유하여 사용&lt;/li&gt;
      &lt;li&gt;파일에 수정이 필요한 경우 이를 쓰기 가능한 레이어에 복사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로, 데이터 볼륨에 대한 관리는 storage driver의 역할이 아니다. 따라서 이 공간의 파일들을 읽고 쓰는 것은 호스트의 네이티브 속도로 이루어진다.&lt;/p&gt;

&lt;h2 id=&quot;storage-driver---&quot;&gt;storage driver의 종류 및 확인&lt;/h2&gt;

&lt;p&gt;도커에서 제공하는 storage driver는 여러 가지이며, 각각은 자신만의 방식으로 컨테이너 및 이미지의 레이어를 관리한다. 따라서 리눅스 환경과 사용 목적을 고려하여 적절한 것을 선택해야 안정성과 성능 측면의 이점을 누릴 수 있다. storage driver의 종류는 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Technology&lt;/th&gt;
      &lt;th&gt;Storage driver name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;OverlayFS&lt;/td&gt;
      &lt;td&gt;overlay&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AUFS&lt;/td&gt;
      &lt;td&gt;aufs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Btrfs&lt;/td&gt;
      &lt;td&gt;btrfs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Device Mapper&lt;/td&gt;
      &lt;td&gt;vfs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VFS*&lt;/td&gt;
      &lt;td&gt;right&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZFS&lt;/td&gt;
      &lt;td&gt;zfs&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;표1. storage driver의 종류 (출처: &lt;a href=&quot;http://goo.gl/DhlZyD&quot;&gt;http://goo.gl/DhlZyD&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;storage driver는 도커 데몬이 실행될 때 결정되며, 아무것도 지정하지 않은 경우에는 시스템 설정을 기반으로 적절한 것이 선택된다(이 때는 안정성&lt;sup&gt;stability&lt;/sup&gt;이 중요한 결정 요소가 된다). 도커의 이미지와 컨테이너의 레이어들을 관리하는 것이 storage driver임을 생각할 때, 데몬 인스턴스에 의해 만들어진 컨테이너들에는 모두 동일한 storage driver가 사용됨을 알 수 있다. 실제로도 그러하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;As a result, the Docker daemon can only run one storage driver, and all containers created by that daemon instance use the same storage driver.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자신이 쓰고 있는 storage driver가 무엇인지 확인하려면 docker info 명령을 입력하면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;[dockeradmin@build-slave containers]# docker info
Containers: 1
 Running: 1
 Paused: 0
 Stopped: 0
Images: 89
Server Version: 1.10.3
Storage Driver: devicemapper
 Pool Name: docker-253:2-5152905-pool
 Pool Blocksize: 65.54 kB
 Base Device Size: 37.58 GB
 Backing Filesystem: xfs
 Data file: /dev/loop0
 Metadata file: /dev/loop1
 Data Space Used: 37.92 GB
 Data Space Total: 107.4 GB
 Data Space Available: 53.15 GB
 Metadata Space Used: 28.38 MB
 Metadata Space Total: 2.147 GB
 Metadata Space Available: 2.119 GB
 Udev Sync Supported: true
 Deferred Removal Enabled: false
 Deferred Deletion Enabled: false
 Deferred Deleted Device Count: 0
 Data loop file: /home/lib/docker/devicemapper/devicemapper/data
 WARNING: Usage of loopback devices is strongly discouraged for production use. Either use `--storage-opt dm.thinpooldev` or use `--storage-opt dm.no_warn_on_loop_devices=true` to suppress this warning.
 Metadata loop file: /home/lib/docker/devicemapper/devicemapper/metadata
 Library Version: 1.02.107-RHEL7 (2015-12-01)
Execution Driver: native-0.2
Logging Driver: json-file
Plugins:
 Volume: local
 Network: bridge null host
Kernel Version: 3.10.0-327.10.1.el7.x86_64
Operating System: CentOS Linux 7 (Core)
OSType: linux
Architecture: x86_64
CPUs: 16
Total Memory: 15.67 GiB
Name: do-build-slave.terracetech.co.kr
ID: NHFZ:QP7R:NJPP:R7CA:3Q4F:7O7F:KO3V:SFSA:LPXF:XBCA:ZTYT:P37I
WARNING: bridge-nf-call-iptables is disabled
WARNING: bridge-nf-call-ip6tables is disabled&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 정보는 현재 Jenkins의 &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin&quot;&gt;Docker Slave&lt;/a&gt;로 활용하는 장비에 대한 것이다. 살펴보면 storage driver는 devicemapper, 파일 시스템은 xfs임을 알 수 있다. 한가지 주목할 만한 것은 WARNING 메시지이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;WARNING: Usage of loopback devices is strongly discouraged for production use. Either use &lt;code class=&quot;highlighter-rouge&quot;&gt;--storage-opt dm.thinpooldev&lt;/code&gt; or use &lt;code class=&quot;highlighter-rouge&quot;&gt;--storage-opt dm.no_warn_on_loop_devices=true&lt;/code&gt; to suppress this warning.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로덕션 환경에서 사용하지 않기를 강하게 권장&lt;sup&gt;strongly discouraged&lt;/sup&gt;한다는 것인데, 다른 대안을 찾는 법에 대해서는 바로 다음에서 설명한다.&lt;/p&gt;

&lt;h2 id=&quot;storage-driver--1&quot;&gt;storage driver 선택하기&lt;/h2&gt;

&lt;p&gt;기본으로 설정되는 storage driver 대신 직접 지정하고 싶다면 어떻게 결정해야 할까? 도커 공식 문서에서는 안정성&lt;sup&gt;stability&lt;/sup&gt;과 경험 및 전문성&lt;sup&gt;experience and expertise&lt;/sup&gt;을 언급하고 있다. 안정성에 대해서는 아래 2개를 권고한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Use the default storage driver for your distribution.&lt;/li&gt;
  &lt;li&gt;Follow the configuration specified on the CS Engine compatibility matrix.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;storage driver는 도커가 설치될 때 시스템 구성에 따라 적절히 선택되는데, 이는 안정성을 고려한 선택이여서 이 기본값을 벗어나는 경우에는 문제를 겪을 가능성이 커진다고 한다. 다음으로는 CS Engine(도커의 상용 버전)의 호환성 매트릭스 명시된 구성을 따르라고 되어 있다. 마찬가지로 이를 따르지 않을 경우 문제를 겪을 가능성이 커진다.&lt;/p&gt;

&lt;p&gt;경험 및 전문성은 단지 자신이 익숙한 것을 쓰는게 도움이 된다는 이야기이다.&lt;/p&gt;

&lt;p&gt;마지막으로, 아래 그림은 각 storage driver의 특성을 비교하는 다이어그램이다. 앞에서 &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin&quot;&gt;Jenkins Docker Slave&lt;/a&gt; 장비의 docker info 내용에서 봤던 경고 메시지처럼, devicemapper (loop)는 production과 performance에서 빨간색 표시(“If bad for use case”를 가리킴)가 되어 있음을 다시 한 번 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.docker.com/engine/userguide/storagedriver/images/driver-pros-cons.png&quot; alt=&quot;&quot; title=&quot;storage driver pros and cons&quot; /&gt;
- 그림 4. storage driver pros and cons (출처: &lt;a href=&quot;http://goo.gl/EVJeGI&quot;&gt;http://goo.gl/EVJeGI&lt;/a&gt;)&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Apr 2016 21:32:18 +0900</pubDate>
        <link>//2016/04/07/docker-storage-driver%E1%84%8B%E1%85%B4-%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2/</link>
        <guid isPermaLink="true">//2016/04/07/docker-storage-driver%E1%84%8B%E1%85%B4-%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2/</guid>
      </item>
    
      <item>
        <title>캡슐화와 정보은닉</title>
        <description>&lt;p&gt;캡슐화(Encapsulation)와 정보은닉(Information Hiding)의 차이에 대해서 설명하는 글들을 찾아봤는데, 의외로 명확하게 설명해주는 것들이 없었다. 아래의 링크는 찾아봤던 것들 중에서 둘 간의 차이를 가장 잘 설명해주는 글이다. 해당 글에 나온 2가지 인용구 및 1개의 간단한 예제와 함께 개인적인 생각들을 정리하도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stefanoricciardi.com/2009/12/06/encapsulation-and-information-hiding/&quot;&gt;The Difference Between Encapsulation and Information Hiding&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;encapsulation&quot;&gt;캡슐화 (Encapsulation)&lt;/h2&gt;

&lt;p&gt;‘Meilir Page-Jones’는 자신의 책인 Fundamental Of Object Oriented Design in UML에서 캡슐화를 다음과 같이 정의하였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Encapsulation is the grouping of related ideas into one unit, which can thereafter be referred to by a single name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;캡슐화는 관련있는 개념들을 한 곳에 무리짓는 것이라고 한다. 그리고 이 무리는 단일 이름으로 불릴 수 있어야 한다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://qph.is.quoracdn.net/main-qimg-3d4963eaf4de2261b6007ef7ef5dad98?convert_to_webp=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 단일 이름(A SINGLE NAME)이라는 단어가 등장하는데, 부족한 이해를 돕는 참 좋은 키워드라는 생각이 든다. 이는 캡슐화가 잘 되었는지 하나의 지표로 볼 수 있겠다. 만약 이름 짓기가 모호하거나 이름이 잘 표현해내지 못하는 행위(API)가 있다면 이는 캡슐화가 잘 안되었을 수도 있는 일종의 냄새가 되는 것이다.&lt;/p&gt;

&lt;p&gt;또 여기서 한 곳(ONE UNIT) 이라는 단어도 언급된다. 이는 클래스를 가리킬 수도 있고, 메서드를 가리킬 수도 있다. 만약 메서드가 캡슐화가 잘 되지 않았다면 하나의 행위를 표현하기 위한 코드들이 두 곳 이상 흩어져 있다는 이야기이다. 이런 경우 관련 있는 코드들을 다시 한 곳에 모아두려는 노력이 필요하며, 이렇게 되면 클라이언트 입장에서는 어떤 행위가 필요할 때 특정 객체의 API만 알고 있으면 된다. 한편, 클래스가 잘 캡슐화 되지 않았다면, 특정 행위가 필요할 때 당최 어떤 클래스에서 찾아야 할지 난감하게 될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;information-hiding&quot;&gt;정보 은닉 (Information Hiding)&lt;/h2&gt;

&lt;p&gt;이 용어는 무려 40년 전에, ‘Parnas’에 의해 소개(On the Criteria to Be Used in Decomposing Systems Into Modules) 되었다고 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Its interface or definition was chosen to reveal as little as possible about its inner workings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;‘Its’라는 부분이 정확히 무엇을 가리키는지는 좀 더 살펴봐야 알겠지만, 정보 은닉에 대한 개념은 이미 언급 – ‘내부의 동작을 외부로부터 최대한 숨기는 것’ – 되었다. 이렇게 세부 사항을 최대한 숨김으로써 변경 사항이 생겼을 때 우리는 그 영향 범위를 최소화 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://previews.123rf.com/images/bowie15/bowie151210/bowie15121000023/15662596-Man-hiding-behind-a-box-Stock-Photo-fear-shy-man.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;둘 간의 차이&lt;/h2&gt;

&lt;p&gt;캡슐화와 정보 은닉에 대한 차이는 어느 정도 얘기된 것 같다. 개인적인 판단으로 둘 간의 차이를 조금 더 명시해 보자면 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;캡슐화: 무리 짓기(Grouping)에 관한 이야기이다. 모듈화가 떠오르기도. 이는 우리가 어떤 행위를 추적(Tracing)하기 쉽도록 도와주며, 예상치 못한 의존성(Unpredictable Dependency)을 제어할 수 있도록 도와준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정보은닉: 추상화(Abstraction)에 관한 이야기이다. 외부에서 알 필요 없는 세부사항을 숨김으로써, 불필요한 의존성(Unnecessary Dependency)를 줄이도록 도와준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;예제 코드&lt;/h2&gt;

&lt;p&gt;위에서 링크를 걸어둔 글에서는 클린 코드에 나온 예제를 들어 두 개념을 설명한다. 예제 자체는 기억 나는데 이것이 캡슐화와 정보은닉을 설명된 것인지는 기억 나지 않는다. (다시 봐야 하나..)&lt;/p&gt;

&lt;p&gt;먼저 첫 번째 예제는 정보 은닉은 되지 않았지만, 캡슐화는 되어 있는 코드이다. 좌표를 표현하기 위한 개념인 x와 y를 모아두었지만, 이것이 외부에게 노출되어 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;두 번째 예제는 이렇게 잘 모아진 개념을 적절하게 숨겼고, x와 y좌표를 잘못 사용할 수 있는 가능성을 줄였으며, 어떻게 사용하는지 이해하기 쉽게 가독성을 높인 예제이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetCartesian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetTheta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetPolar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-2&quot;&gt;그래서?&lt;/h2&gt;

&lt;p&gt;사실 둘의 개념은 꼭 구분해서 알아야 할 필요가 있나 싶다. 둘의 차이를 알기 전과 알고 난 후의 설계와 코드는 동일할 것 같기 때문이다. 분명히 다른 개념인 동시에 매우 밀접한 관계이기도 해서, 단지 궁금해서 찾아본 내용일 뿐이다. 다만, 의사소통 할 때 좀 편할 경우가 있을까 싶긴 하다.&lt;/p&gt;

&lt;p&gt;캡슐화에 관한 정의들을 소개하는 것으로 글은 마무리.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It […] refers to building a capsule, in the case a conceptual barrier, around some collection of things. — [Wirfs-Brock et al, 1990]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;As a process, encapsulation means the act of enclosing one or more items within a […] container. Encapsulation, as an entity, refers to a package or an enclosure that holds (contains, encloses) one or more items.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If encapsulation was ‘the same thing as information hiding,’ then one might make the argument that ‘everything that was encapsulated was also hidden.’ This is not obviously not true.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 08 Aug 2013 21:32:18 +0900</pubDate>
        <link>//2013/08/08/%E1%84%8F%E1%85%A2%E1%86%B8%E1%84%89%E1%85%B2%E1%86%AF%E1%84%92%E1%85%AA%E1%84%8B%E1%85%AA-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%82%E1%85%B5%E1%86%A8/</link>
        <guid isPermaLink="true">//2013/08/08/%E1%84%8F%E1%85%A2%E1%86%B8%E1%84%89%E1%85%B2%E1%86%AF%E1%84%92%E1%85%AA%E1%84%8B%E1%85%AA-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%82%E1%85%B5%E1%86%A8/</guid>
      </item>
    
      <item>
        <title>Law of Demeter</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://alaskabibleteacher.files.wordpress.com/2015/07/train_wreck_at_montparnasse_1895-1895-10-22.jpg?w=423&amp;amp;h=508&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;벤캣 수브라마니암, 앤디 헌트의 &lt;strong&gt;애자일 프랙틱스&lt;/strong&gt;에는 다음과 같은 이야기가 나온다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다른 객체는 신뢰하지 마. 결국 다른 사람이 작성한 거고, 네가 했더라도 똑똑하다 할 수 없던 지난달에 작성한 거란 말이지. 다른 객체에서 필요한 정보를 얻어서, 스스로 계산하고, 스스로 결정 내려. 다른 객체에 대한 통제력을 포기하지 마!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;묻지 말고 말하라는 원칙을 설명하는 부분에 앞서, 우리가 쉽게 다른 객체를 의심하며 코드를 작성하는 습관을 꼬집는 이야기이다. 한편, 알렉 샤프(Alec Sharp)는 이렇게 이야기했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;절차적인 코드는 정보를 얻고 나서 결정을 한다. 객체지향 코드는 객체에게 행동을 하게 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우리는 이웃 객체를 호출할 때 해당 객체가 무엇을 원하는지 기술하고, 호출된 객체가 그러한 바를 어떻게 실현할지 결정하게 해야 한다. 이웃 객체의 세부 내용은 우리의 책임이 아니다. 이는 다른 말로, 그리고 좀 더 형식적으로는 디미터의 법칙(Law of Demeter)으로 알려져 있다.&lt;/p&gt;

&lt;p&gt;이런 원칙을 따르게 되면, 코드가 좀 더 유연해진다. 이는 호출자가 객체의 내부 구조나 역할 인터페이스 너머에 존재하는 시스템에 대해서 알 필요가 없기 때문이다. 객체가 세부 사항을 모른다는 것은 객체가 변경되어야 할 때 우리가 살펴봐야 하는 범위가 줄어든다는 이야기이다. 다르게 얘기하면, 우리가 객체 외부에서 그 객체와 관련된 결정을 하는 것은 객체의 캡슐화(Encapsulation)를 위반하게 되고 결국 잠재적 결함을 만들게 된다는 이야기이다.&lt;/p&gt;

&lt;p&gt;한편 이러한 원칙은 코드의 목적을 한번에 설명할 수 있는 이름이 생기는 추가적 이점을 가져다 준다. 더불어, 관련된 코드를 한 곳에 몰아두어 의도를 드러낼 수 있기도 하다.&lt;/p&gt;

&lt;p&gt;이와 관련하여 신문 배달 소년과 지갑이라는 재미있는 이야기도 있다. 소년이 신문 배달을 하러 왔고 비용을 2달러를 지불하라고 했다. 그러자 신문을 받아든 사람은 직접 돈을 지불하는 대신 뒤로 돌아섰고, 소년은 그 사람의 지갑을 꺼내어 2달러를 뺀 후 다시 주머니에 집어 넣었다. 그리고 소년은 반짝이는 재규어를 몰고 다닌다고 한다. 2달러를 지불하는 것은 고객의 책임이지, 소년의 책임이 아니다. 원래의 글은 아래 링크를 참조.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf&quot;&gt;http://www.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Jul 2013 21:32:18 +0900</pubDate>
        <link>//2013/07/04/law-of-demeter/</link>
        <guid isPermaLink="true">//2013/07/04/law-of-demeter/</guid>
      </item>
    
      <item>
        <title>TDD와 BDD의 차이</title>
        <description>&lt;p&gt;마이크로소프트에 기고한 TDD와 BDD 내용 중, 코드 작성에 관한 부분을 옮겨 왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.hascode.com/wp-content/uploads/2011/05/bdd.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 전에 앞서 약간의 의견을 담아내자면, BDD에 대해서는 다소 회의적이다. 둘 간의 차이가 크지 않고 BDD가 가진 철학이 이미 충분히 TDD에 반영되어 있을 수 있다. 그런 철학은 꼭 BDD만의 것이라고 하기에는 다소 민망하다. 그럼에도 불구하고 차이를 언급했던 것은, 혹시나 차이를 설명하는 과정에서 TDD/BDD에 익숙하지 않은 사람들이 아이디어를 얻어갈 수 있지 않을까 하는 막연한 기대 때문이었다. 아래는 기고 당시의 일부 내용이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이제부터는 간단하게 친구신청/확인 기능을 TDD와 BDD로 작성해보며 이 둘을 살펴보려 한다. 제한된 공간안에 TDD와 BDD를 설명해야 하기 때문에, 바로 구현으로 들어가도 될 만큼 작은 기능을 대상으로 선정했지만, 간단히 기능 정의를 하고 시작하도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;기능 정의&lt;/h2&gt;

&lt;p&gt;친구 신청/확인에 필요한 기능은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자는 친구를 맺기 위해, 상대방에게 친구 신청을 할 수 있다.&lt;/li&gt;
  &lt;li&gt;사용자는 다른 사용자와의 친구 여부를 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간단하게 클래스로 만들어 볼 수 있는 대상은 2개 정도가 될 것 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자&lt;/li&gt;
  &lt;li&gt;친구신청/확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 기능이 크지 않으므로, 사용자 클래스 하나를 두고 이 안에서 친구 신청 및 확인 기능을 함께 구현하도록 한다. 정리하면, 사용자 클래스 하나에 친구신청, 친구확인 기능이 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;tdd&quot;&gt;TDD&lt;/h2&gt;

&lt;p&gt;우선, TDD로 이 내용을 구현해보도록 한다. 가장 먼저 무엇을 테스트해보는게 좋을까? 친구 여부를 확인하기 위해서는 친구 신청을 먼저 구현해야 할 것 같다. 그런데 잠깐, 친구 신청을 했는지 확인하려면 친구 여부 확인이 먼저 필요한 것 아닐까? 이런 경우는 그냥 둘다 함께 확인 가능한 테스트 코드를 작성하면 된다.&lt;/p&gt;

&lt;p&gt;먼저 위에서 정의한 기능을 User 클래스의 메서드로 선언한다.&lt;/p&gt;

&lt;p&gt;User.java&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Getter&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// TODO&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendFriendRequestTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// TODO&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isFriendWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// TODO&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그리고 이를 확인하기 위해 작성한 코드는 다음과 같다.&lt;/p&gt;

&lt;p&gt;UserTest.java&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendRequestTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Given&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// When&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendFriendRequestTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isFriendWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A라는 이름의 사용자와, B라는 이름의 사용자가 전제조건(Given)으로 주어져 있고, A가 B에게 친구 요청을 던진 경우(When), A가 B와 친구가 되었는지를 확인(Then)하고 있다. 이제 User의 내부를 빠르게 구현해보면, 다음과 같은 코드가 나온다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Getter&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;friends&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendFriendRequestTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isFriendWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;대부분 금방 눈치 챘겠지만, 코드를 보면 B의 입장에서 A가 친구인지의 여부가 의심이 될 것이다. 이런 경우라면 다음과 같이 Test 케이스를 추가해 확인해 볼 수 있다.&lt;/p&gt;

&lt;p&gt;UserTest.java&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;생략&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendRequestTo_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;상대방에게&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;요청을&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;받은&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;경우&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Given&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// When&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendFriendRequestTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;친구 요청을 받으면 친구가 되야 한다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isFriendWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;필요하다면 다음과 같이 메서드에 설명을 붙여 케이스를 추가해 나갈 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;isFriendWith_친구신청_하지_않은_경우&lt;/li&gt;
  &lt;li&gt;sendRequestTo_중복으로_친구신청을_한_경우&lt;/li&gt;
  &lt;li&gt;그 외&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런데 잠깐, 새롭게 추가한 테스트 케이스가 실패함을 확인할 수 있다. 이는 단방향이 아니라 양방향의 관계를 작성하는 것이 익숙치 않은 경우 종종 발생하는 문제이다. User 클래스는 아래와 같이 고쳐서 Test 코드를 성공으로 돌려놓을 수 있다.&lt;/p&gt;

&lt;p&gt;User.java&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;생략&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendFriendRequestTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 동기화 코드가 필요함&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;생략&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 코드는 친구 중복에 관한 처리 등을 비롯해 테스트 케이스 추가와 코드 보완, 리팩토링이 필요하지만 코드 소개의 목적이 TDD와 BDD의 비교이므로, 일단 이것으로 TDD에 대한 간단한 소개를 마치도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;bdd&quot;&gt;BDD&lt;/h2&gt;

&lt;p&gt;이번에는 똑같은 기능을 BDD로 작성해보도록 하자. BDD를 작성하는데 사용한 프레임웍은 JBehave 이다. 총 5계의 단계를 거쳐 작성을 하게 되는데 이 순서는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;스토리 작성&lt;/li&gt;
  &lt;li&gt;시나리오를 실행시킬 Step 클래스(POJO)를 작성한다.&lt;/li&gt;
  &lt;li&gt;Embeddable 클래스를 작성하여 관련된 설정을 지정한다.&lt;/li&gt;
  &lt;li&gt;시나리오를 실행시킨다.&lt;/li&gt;
  &lt;li&gt;결과를 확인한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;스토리 작성&lt;/h3&gt;

&lt;p&gt;가장 먼저 스토리를 작성한다. 위에서 정의한 기능을 토대로 다음과 같이 작성해볼 수 있다.&lt;/p&gt;

&lt;p&gt;friend_request_story.story&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;Narrative:
사용자는,
친구를 맺기 위해,
다른 사용자에게 친구 신청을 할 수 있다.
Scenario: 친구 요청
Given ‘A’라는 사용자가 있다.
And ‘B’라는 사용자가 있다.
When &#39;A&#39;가 &#39;B&#39;에게 친구 신청을 한다.
Then &#39;A&#39;는 &#39;B&#39;와 친구가 된다.
Scenario: 친구 요청 (받는 경우)
Given ‘A’라는 사용자가 있다.
And ‘B’라는 사용자가 있다.
When &#39;B&#39;가 &#39;A&#39;에게 친구 신청을 한다.
Then &#39;A&#39;는 &#39;B&#39;와 친구가 된다.
And ‘B’는 ‘A’와 친구가 된다.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Narrative, Scenario 용어가 사용된 부분은 꼭 지켜줘야 하는 문법(JBehave 혹은 Grekin Language)이다.&lt;/p&gt;

&lt;p&gt;크게 2가지로 구성되는데, Narrative 부분은 테스트 대상이 되는 스토리를 설명하는 부분이다. 이 형식은 애자일 개발 방법에서 많이 사용하는 사용자 스토리(User Story) 작성 템플릿으로, 역할(Role) – 기능(Feature) – 목적(Benefit)의 요소로 구성되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As a [역할]&lt;/li&gt;
  &lt;li&gt;I want [기능]&lt;/li&gt;
  &lt;li&gt;So that [목적]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 형식이 기본 템플릿인데, 한글로 작성하였기 때문에 순서를 바꾸어 작성하였다.&lt;/p&gt;

&lt;p&gt;다음으로 Scenario 부분이다. Given에 주어진 조건을 적고, When에 테스트 하고 싶은 어떤 행위를 기술하면 된다. 그리고 마지막 Then에는 기대하는 결과를 작성하면 된다. 기본적인 형식은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Given [주어진 조건]&lt;/li&gt;
  &lt;li&gt;And [주어진 다른 조건] …&lt;/li&gt;
  &lt;li&gt;When [행위 또는 사건]&lt;/li&gt;
  &lt;li&gt;Then [결과]&lt;/li&gt;
  &lt;li&gt;And [다른 결과] …&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스토리를 작성하는 방법에 대해서 자세히 알고 싶으면 다음의 글을 참조하도록 한다. &lt;a href=&quot;http://dannorth.net/whats-in-a-story&quot;&gt;http://dannorth.net/whats-in-a-story&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;step--&quot;&gt;Step 클래스 작성&lt;/h3&gt;

&lt;p&gt;friend_request_story와 이름 구조를 맞춰 주어야 하므로, FriendRequestStep이라는 이름으로 다음과 같은 Step클래스를 작성하였다.&lt;/p&gt;

&lt;p&gt;FriendRequestStep.java&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FriendRequestStep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UserRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@BeforeStories&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setUp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UserRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&#39;$userName&#39;라는 사용자가 있다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;givenThereIsUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@When&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&#39;$senderName&#39;가 &#39;$receiverName&#39;에게 친구 신청을 한다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whenSendFriendRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;senderName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiverName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;senderName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiverName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendFriendRequestTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Then&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&#39;$senderName&#39;는 &#39;$receiverName&#39;와 친구가 된다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thenTheyAreFriend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;senderName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiverName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;senderName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiverName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isFriendWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// DB 관련된 사항이 결정되지 않았다고 가정하고 도우미 클래스를 만든다.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UserRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;우선, User 데이터들을 관리하는 모듈이 필요한데, 여기서는 DB Access(DAO, Repository 사용 여부 등) 관련 사항이 결정되지 않아서 UserRepository라는 Mock을 사용하였다. 이런 식으로, 아직 구현되지 않은 모듈이 있는 경우에도, 원래 구현하려던 기능에 집중하여 코드를 작성할 수 있다. 추후 DB관련 사항이 결정되면 UserRepository를 실제 모듈로 대체할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;@BeforeStory 부분은 시나리오를 실행하기 전에 환경적인 부분을 설정하는 곳이다. 물론, 데이터를 미리 설정하는 공간으로 활용할 수도 있지만, 필자는 주로 환경적인 부분을 만드는데 이를 활용하여 @Given과의 용도를 구분한다.&lt;/p&gt;

&lt;p&gt;@Given, @When, @Then은 story 파일에서 Given, When, Then을 매핑하는 애노테이션이다. 그리고 각 애노테이션 안에 story의 각 문장을 매핑하는 값들이 있다. 달러($)표시로 시작하는 부분은 story 파일에서 마음대로 값을 지정할 수 있는 부분을 의미한다. 이런 특징으로 인해, 하나의 매핑 메서드에 여러개의 문장을 다양한 값으로 대응시킬 수 있는데, 이는 JBehave가 주는 꽤나 좋은 이점이다. 프레임웍 없이 작성했다고 하면, 우리는 일일이 똑같은 테스트 메서드를 추가하여 그 안에 Given이나 When등을 작성해야 했을 것이다.&lt;/p&gt;

&lt;p&gt;실제로 Given에서 표현한 2개의 문장은, 하나의 메서드로 모두 수행 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Step 메서드: givenThereIsUser&lt;/li&gt;
  &lt;li&gt;Scenario 문장&lt;/li&gt;
  &lt;li&gt;Given ‘A’라는 사용자가 있다.&lt;/li&gt;
  &lt;li&gt;And ‘B’라는 사용자가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약, 한 명의 사용자를 더 두어 시나리오를 테스트하고 싶거나, 또 다른 시나리오를 추가하려는 경우 이러한 재사용은 점점 이점으로 다가올 것이다. 흔히, Step 클래스는 Story의 Type이며, Story는 이 시스템의 구체적 행위이자 인스턴스라고 표현하기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;embeddable--&quot;&gt;Embeddable 클래스를 작성&lt;/h3&gt;
&lt;p&gt;여기서 설정 코드를 작성하는 것은 생략하도록 한다. 이 설정에서는 story를 step에 매핑하는 방식이라던지, 결과를 어떤 형태로 보여줄 것인지 등을 결정할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;시나리오 실행&lt;/h3&gt;
&lt;p&gt;JUnit을 통해 우리는 결과를 확인할 수 있는데, 위의 경우 다음과 같은 결과를 확인할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeforeStories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Running&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;story&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;friend_request_story&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;story&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;friend_request_story&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;story&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;Scenario:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;친구&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;요청&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Given&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Jobs&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;라는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;사용자가&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;있다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;And&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gates&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;라는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;사용자가&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;있다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;When&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Jobs&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;가&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gates&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;에게&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;친구&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;신청을&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;한다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Then&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Jobs&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gates&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;와&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;친구가&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;된다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;tdd-tdd&quot;&gt;코드를 통해 느껴본 TDD와 TDD&lt;/h2&gt;

&lt;p&gt;지금까지 친구 신청/확인 기능을 구현하는 TDD와 BDD에 대해서 살펴보았다. 위에서 살펴본 것처럼, TDD와 BDD의 의미 있는 차이라고 한다면, story 파일의 존재이다. 이것은 비 개발자와 소통하는 동시에 시스템의 행위를 보존해주는 도구로 사용될 수도 있다. 분명, 도표나 그림등을 통해서 더 많은 것을 쉽게 표현할 수도 있기 때문에, 시나리오로 모든 것을 표현하는 데에는 한계가 있다. 그럼에도 불구하고 필자는 코드를 작성하기 전에 이런 시나리오들을 간단히 작성해 보는 것을 좋은 개발 시작 지점으로 삼을 수 있었다. JBehave는 이것을 프레임웍에서 지원해주며, 이것이 BDD가 가진 주요 철학 중 하나이다.&lt;/p&gt;

&lt;p&gt;더불어, 프레임웍을 통해서 TDD의 반복되는 코드 작업을 줄여주는 이점을 취할 수도 있다. 프레임웍을 사용하지 않는 경우, 여러 케이스를 표현하기 위해 중복되는 코드들이 나오기 마련이다. 이를 SetUp(JUnit에서는 @Before 애노테이션 사용)부분에 넣으면, 반복 작업은 줄지만 가독성이 떨어지고 점점 코드가 복잡해질 여지가 있다. 해서, 어느 정도의 반복작업을 하게 되는 것이다. 그런데 JBehave는 위에서 보듯 Step을 Type으로 작성하여, 여러 시나리오들을 좀 더 수월하게 테스트해볼 수 있었다. 이는 테스트 코드 관리의 부담을 줄여주는 하나의 방법이 될 수 있다고 본다.&lt;/p&gt;

&lt;p&gt;그 외에, In-Out 방식과 시나리오 형태로 테스트 주도 개발을 할 수 있다는 점은 BDD(정확히는 JBehave 프레임웍이)가 강제하는 형식이다. 물론, Out-In 방식이 유리한 경우도 있고, 시나리오가 아닌 단순 스펙 확인 방식이 좋은 경우도 있다. BDD 프레임웍이 이런 유연성을 제한하는 것은 분명 한계일 것이다. 그럼에도 불구하고, BDD가 가진 철학들은 한 번은 적용해볼 만한 내용일 것이다.&lt;/p&gt;
</description>
        <pubDate>Sat, 18 May 2013 21:32:18 +0900</pubDate>
        <link>//2013/05/18/TDD%E1%84%8B%E1%85%AA-BDD%E1%84%8B%E1%85%B4-%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%B5/</link>
        <guid isPermaLink="true">//2013/05/18/TDD%E1%84%8B%E1%85%AA-BDD%E1%84%8B%E1%85%B4-%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%B5/</guid>
      </item>
    
  </channel>
</rss>
